## 附录 G - Rust 是如何制造的以及“夜间 Rust”

本附录介绍 Rust 的制作方式以及它如何影响 Rust
开发商。

### 稳定不停滞

作为一种语言，Rust 非常关心代码的稳定性。我们想要
Rust 是你可以构建的坚如磐石的基础，如果事情是这样的话
不断变化，那是不可能的。同时，如果我们不能
尝试新功能，我们可能直到之后才能发现重要的缺陷
当我们无法再改变事情时，他们就被释放了。

我们解决这个问题的办法就是所谓的“稳定而不停滞”，
我们的指导原则是：您永远不必担心升级到
新版本的稳定 Rust。每次升级都应该是无痛的，但也应该
为您带来新功能、更少的错误和更快的编译时间。

### 楚楚，楚楚！发布渠道和乘坐列车

Rust 开发按照_火车时间表_ 进行。也就是说，一切的发展都是
在 Rust 存储库的主分支中完成。发布遵循软件
发布火车模型，已被Cisco IOS和其他软件使用
项目。 Rust 有三个_发布渠道_：

- Nightly
- Beta
- Stable

大多数 Rust 开发人员主要使用稳定渠道，但那些想要使用稳定渠道的人
尝试实验性新功能可能会使用 nightly 或 beta。

以下是开发和发布过程如何工作的示例：让我们
假设 Rust 团队正在致力于发布 Rust 1.5。那个发布
发生在2015年12月，但它将为我们提供现实的版本
数字。 Rust 中添加了一个新功能：一个新的提交落在主干上
分支。每天晚上，都会生成一个新的 Rust 夜间版本。每一天都是一个
发布日，这些发布是由我们的发布基础设施创建的
自动地。随着时间的推移，我们的发布看起来像这样，每晚一次：

```text
nightly: * - - * - - *
```

每六周，就该准备一个新版本了！的“beta”分支
Rust 存储库从 nightly 使用的主分支中分支出来。现在，
有两个版本：

```text
nightly: * - - * - - *
                     |
beta:                *
```

大多数 Rust 用户不会主动使用 beta 版本，而是在
他们的 CI 系统帮助 Rust 发现可能的回归。同时，
每天晚上仍然有一个夜间版本：

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

假设发现了回归。还好我们有时间测试 Beta 版
在回归潜入稳定版本之前发布！修复已应用
到主分支，以便每晚得到修复，然后将修复向后移植到
`beta` 分支，并生成了新的 beta 版本：

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

第一个测试版创建六周后，是时候发布稳定版本了！这
`stable` 分支是从 `beta` 分支产生的：

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

万岁！ Rust 1.5 完成了！然而，我们忘记了一件事：因为这六个
几周过去了，我们还需要 Rust _next_ 版本 1.6 的新测试版。
因此，在“stable”从“beta”分支出来之后，下一个版本的“beta”分支
再次关闭“每晚”：

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

这被称为“火车模型”，因为每六周就会有一个版本“离开
站”，但在此之前仍需通过测试版通道
作为稳定版本发布。

Rust 每六周发布一次，就像发条一样。如果您知道 Rust 的日期
发布后，您可以知道下一个发布的日期：六周后。一个不错的
每六周安排一次发布的一个方面是下一趟列车是
即将推出。如果某个功能碰巧错过了特定版本，则无需
担心：很快就会发生另一件事！这有助于减轻压力
在接近发布截止日期的时候隐藏可能未完善的功能。

感谢这个过程，您可以随时查看 Rust 的下一个版本并
亲自验证是否可以轻松升级到： 如果测试版不支持
按预期工作，您可以向团队报告并在发布之前修复它
下一个稳定版本即将发布！测试版中的损坏相对较少，但是
`rustc` 仍然是一个软件，并且确实存在错误。

### 维护时间

Rust 项目支持最新的稳定版本。当新的稳定
版本发布后，旧版本已达到其生命周期 (EOL)。这意味着
每个版本的支持时间为六周。

### 不稳定的功能

这个发布模型还有一个问题：不稳定的功能。 Rust 使用一个
称为“功能标志”的技术，用于确定在某个功能中启用了哪些功能
给予释放。如果一项新功能正在积极开发中，它将出现在
主分支，因此，在每晚，但在 _feature flag_ 后面。如果你，作为
一个用户，想要尝试正在进行中的功能，你可以，但你必须
使用 Rust 的夜间版本并使用以下内容注释您的源代码
选择加入的适当标志。

如果您使用 Rust 的测试版或稳定版，则无法使用任何功能
旗帜。这是让我们能够实际使用新功能的关键
在我们宣布它们永远稳定之前。那些想要选择出血的人
Edge 可以做到这一点，那些想要坚如磐石的体验的人可以坚持使用
稳定并知道他们的代码不会损坏。稳定无停滞。

本书仅包含有关稳定功能（正在进行中）的信息
功能仍在变化，并且肯定会有所不同
本书已完成，并且它们何时在稳定版本中启用。你可以找到
仅夜间功能的在线文档。

### Rustup 和 Rust Nightly 的作用

Rustup 可以轻松地在 Rust 的不同发布渠道之间进行更改
全局或每个项目的基础。默认情况下，您将安装稳定的 Rust。到
每晚安装，例如：

```console
$ rustup toolchain install nightly
```

您可以看到所有_工具链_（Rust 的版本和相关的
组件），您也使用 `rustup` 安装了。这是一个例子
作者的 Windows 计算机：

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

如您所见，稳定的工具链是默认的。大多数 Rust 用户使用 stable
大多数时候。大多数时候你可能想使用 stable，但是使用
每晚都在某个特定项目上，因为您关心一项前沿功能。
为此，您可以在该项目的目录中使用“rustup override”来设置
每晚工具链作为您在该目录中时应该使用的“rustup”：

```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```

现在，每次你在里面调用 `rustc` 或 `cargo` 时
_~/projects/needs-nightly_, `rustup` 将确保您正在使用 nightly
Rust，而不是默认的稳定 Rust。当您
有很多 Rust 项目！

### RFC 流程和团队

那么如何了解这些新功能呢？ Rust 的开发模型如下
_征求意见 (RFC) 流程_。如果你想改进 Rust，
您可以写一个提案，称为 RFC。

任何人都可以编写 RFC 来改进 Rust，并且提案会经过审查和
由 Rust 团队讨论，该团队由许多主题子团队组成。有
团队的完整列​​表 [在 Rust 的网站上](https://www.rust-lang.org/governance)，其中包括以下团队：
项目的每个领域：语言设计、编译器实现、
基础设施、文档等。适当的团队阅读
提案和评论，写一些自己的评论，最后，
一致同意接受或拒绝该功能。

如果该功能被接受，则会在 Rust 存储库上打开一个问题，并且
有人可以实现它。执行得很好的人可能不是
最先提出该功能的人！当执行时
准备好后，它会落在功能门后面的主分支上，正如我们在
[“不稳定的功能”](#unstable-features)<!-- 忽略 --> 部分。

一段时间后，使用夜间版本的 Rust 开发人员已经能够
为了尝试新功能，团队成员将讨论该功能及其使用方式
在 nightly 上进行了研究，并决定是否应该将其变成稳定的 Rust。
如果决定继续前进，则删除功能门，然后
功能现在被认为是稳定的！它带领列车进入新的稳定版本
铁锈。
